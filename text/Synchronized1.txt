# synchronized block in C++

* 작성: 2005-08-07
* 최종수정: 2005-08-11
* 태그: 멀티스레드 프로그래밍

관련글: [Synchronized2]

<code:Cpp>
ACriticalSection someCriticalSection;

synchronized(someCriticalSection)
{
	...
}	
</code>

C++에서 이런 코드를 쓸 수 있으면 공유 데이터의 락킹이 꽤 간단해지겠다는 생각이 들었습니다. 보통의 Lock()과 Unlock() 호출 방식은 락을 건 뒤 중간에 블럭에서 빠져나가거나 할 때 어디서 언락하는지가 좀 헷갈리고 불필요한 상태변수가 추가되거나 코드가 지저분해지는 경향이 있으니까요.


<code:Cpp>
class AutoLock
{
public:
	AutoLock( ACriticalSection& cs ) : cs(cs)
	{
		cs.Lock();
		cont = true;
	}
	~AutoLock()
	{
		cs.Unlock();
	}
private:
	ACriticalSection&  cs;
};
</code>
<code:Cpp>
{
	AutoLock(someCriticalSection);
	...
}
</code>

목적을 위해서는 '지역 객체의 자동 소멸을 통한 자원 해제 관용구'를 쓸 수도 있지만, synchronized()를 쓰는 것보다 코드가 예쁘지 않습니다. 그래서 이리저리 생각해 봤는데, 한가지 방법이 떠오르더군요. (몇 년 전에 친구가 자기 회사에서는 synchronized() 매크로를 만들어 쓴다는 얘기를 한 적이 있기 때문에, 가능할 거라는 확신은 있었거든요)


<code:Cpp>
class AutoLock
{
public:
	AutoLock( ACriticalSection& cs ) : cs(cs)
	{
		cs.Lock();
		cont = true;
	}
	~AutoLock()
	{
		cs.Unlock();
	}
	void P()
	{
		cont = false;
	}
	bool C()
	{
		return cont;
	}
private:
	ACriticalSection&  cs;
	bool cont;
};

#define synchronized(A)    for(AutoLock _syncVar(A); _syncVar.C(); _syncVar.P())
</code>

for루프를 단 한번만 실행되도록 강제하고, 블록을 벗어나면 스코프 룰을 통해 _syncVar가 자동으로 해제되도록 합니다. 우와! 성공! ＼( ´ ∇`)ノ


그런데 이 방법에는 단점이 있습니다. 다른 for문과 간섭한다는 것인데, 아래 코드를 보시죠.

<code:Cpp>
for( ... )
{
	synchronized(someCriticalSection)
	{
		if( blahblah )
			break;
	}
	// here
}
// there
</code>

중간에 if 안의 blahblah가 만족되면, 코드상으로는 there로 나와야 할 것 같지만, synchronized 블럭이 for문으로 전개되기 때문에 실제론 here로 가 버립니다. synchronized 블럭이 사실은 for니까 break도 continue도 for처럼 작동할 거라는 걸 염두에 두고 쓸 수는 없지요(피곤하니까요). 이는 잠재적인 버그의 구멍이 됩니다.


게다가 Visual C++ 6에선 for루프 관련 스코프 룰을 정확히 처리하지 못하니 아예 쓸 수 없습니다.

<code:Cpp>
// VC6에서 바보 되는 대표적인 케이스

synchronized(someCriticalSection)
{
	...
}

synchronized(someCriticalSection)
{
	...
}
</code>


그래서, 비슷한 생각을 한 사람이 있지 않을까- 하고 찾아 봤습니다.
바로 나오네요. :D

[똑같은 접근:http://brickos.sourceforge.net/docs/APIs/html-c++/CriticalSectionBlock_8H.html]
[if를 사용함:http://www.codeproject.com/threads/synchronized.asp]

두번째 링크의 글을 읽고서 if로 다시 만들어봤습니다.

<code:Cpp>
class AutoLock
{
public:
	AutoLock( ACriticalSection& cs ) : cs(cs)
	{
		cs.Lock();
	}
	~AutoLock()
	{
		cs.Unlock();
	}
	operator bool()
	{
		return true;
	}

private:
	ACriticalSection&  cs;
};

#define synchronized(A)		if( AutoLock _syncVar = A )
</code>

잘 됩니다+_+!

코드도 훨씬 짧고, for루프 같은 문법적인 함정도 없고 성능도 더 뛰어납니다. if 안에 새로운 변수를 선언할 수 있는지는 미처 몰랐네요. (...)

그리고 놀라운 것이 하나 더!




무려 VC6에서 잘 작동합니다. (...)










덧. ACriticalSection을 지원해준 아쥬에게 감사 'ㅁ'/