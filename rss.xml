<?xml version="1.0" encoding="utf-8" ?>
<rss version='0.92'>
<channel>
	<docs></docs>
	<title>lee-seungjae.github.io</title>
	<link>http://lee-seungjae.github.io/</link>
	<description></description>

			<item>
			<title>인터뷰</title>
			<pubDate>26 Apr 2016 00:00:00 +0900</pubDate>
			<description>
			<![CDATA["데스크탑 히어로즈 정리할 때쯤, 다시는 동적 타입 언어로 큰 프로그램 만들지 않겠다고 결심했어요. 마비노기 2에서 AI 스크립팅 시스템 만들 때도, 단순 실수를 컴파일 타임에 못 잡는다는 점 때문에 정적 타입 스크립팅 언어를 새로 만들기도 했고요.

제가 2014년 가을에 듀얼에 합류했는데, 상황이 썩 좋지 않았어요. 듀얼 서버가 아직 매끈하게 돌고 있지 않았고, 여러 해 동안 진행하던 큰 프로젝트가 드랍된 뒤였기 때문에 스튜디오 분위기도 침체돼 있었어요. 시간이 없다, 최대한 빨리 사내테스트와 CBT를 해서 분위기를 반전시켜야 한다, 그게 제 판단이었어요. 그때까지 만들던 C# 서버 코드를 모두 버리고 새로 시작하기로 하면서 Lua를 골랐죠. 클라이언트가 Lua로 되어있기도 했고, 제가 Lua 다뤄본 경험이 많았거든요. 가장 빨리, 시행착오 거치지 않고 서비스하려면 Lua가 최선일 거라고 봤어요. 장기적으로 유지보수 문제가 있을 거라는 거 당연히 알고 있었지만 빨리 출시하는 게 그때는 더 중요했어요. 제가 참여해서 출시한 게임이 이렇게 오래... 서비스하고 있는 게 처음이라서, 유지보수 문제를 걱정할 수 있다는 게 행복한 상황이라고 생각해요.

지금의 경험을 가지고 그때로 돌아가도 같은 선택을 하겠냐고 물으신다면, 예, 그렇게 할 거예요. 극단적인 상황에서 내렸던 극단적인 선택이었고, 다른 상황에서는 다른 선택을 하겠죠."...]]>
			</description>
			<link>http://lee-seungjae.github.io/Interview.html</link>
		</item>
			<item>
			<title>NDC14 - 사례로 배우는 디스어셈블리 디버깅</title>
			<pubDate>27 May 2014 00:00:00 +0900</pubDate>
			<description>
			<![CDATA[<TAG>
<iframe src="http://www.slideshare.net/slideshow/embed_code/35166099" width="687" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe>
</TAG>

2014년 5월 27일, 25분 세션....]]>
			</description>
			<link>http://lee-seungjae.github.io/DisassemblyDebugging.html</link>
		</item>
			<item>
			<title>처리량과 활용</title>
			<pubDate>30 Mar 2014 00:00:00 +0900</pubDate>
			<description>
			<![CDATA[Throughput(처리량)과 Utilization(활용)은 서로 다른 개념이다. 처리량은 같은 시간 동안 얼마나 많은 일을 해낼 수 있느냐를 뜻한다. 활용은 일꾼을 얼마나 바쁘게 일하게 하는지를 뜻한다. 처리량은 높을수록 좋다. 대체로 활용을 높이면 처리량도 따라서 높아지는 경향이 있지만 반드시 그런 것은 아니다.

처리량과 활용을 헷갈리면 '함수형 언어는 멀티코어를 활용하기 쉬워서 좋다' 같은 얘기를 하게 된다. 이 문장은 옳은지 그른지와 상관없이 별로 쓸모가 없다. 함수형 언어의 구현에 비효율이 있다면 활용이 높더라도 처리량은 낮을 수 있기 때문이다. 이를 쓸모있게 바꾸려면 '함수형 언어를 쓰면 적은 노력으로 높은 처리량을 달성할 수 있는데, 왜냐하면 멀티코어를 활용하기 편하기 때문이다' 로 고쳐 써야 하고, 실제로 처리량이 높음을 실측 자료로 보여야 한다....]]>
			</description>
			<link>http://lee-seungjae.github.io/ThroughputAndUtilization.html</link>
		</item>
			<item>
			<title>NDC13 - M2 AI코드 개발 생산성 향상 사례</title>
			<pubDate>28 Apr 2013 00:00:00 +0900</pubDate>
			<description>
			<![CDATA[<TAG>
<iframe src="http://www.slideshare.net/slideshow/embed_code/19986914?rel=0" width="687" height="486" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/devcatpublications/m2-ai-ndc2013" title="이승재, M2 AI코드 개발 생산성 향상 사례, NDC2013" target="_blank">이승재, M2 AI코드 개발 생산성 향상 사례, NDC2013</a> </strong> from <strong><a href="http://www.slideshare.net/devcatpublications" target="_blank">devCAT Studio, NEXON</a></strong> </div>
</TAG>

2013년 4월 24일, 50분 세션....]]>
			</description>
			<link>http://lee-seungjae.github.io/CodeHotloadingAndInHouseScriptLanguage.html</link>
		</item>
			<item>
			<title>Array(Vector) vs HashMap</title>
			<pubDate>21 Jun 2012 00:00:00 +0900</pubDate>
			<description>
			<![CDATA[삽입/삭제 패턴이 어떻게 되나?
조회 패턴이 어떻게 되나?
얼마나 많은 원소를 담아야 하나?
얼마나 많은 메모리 오버헤드를 감수할 수 있나?
담을 원소의 크기는 얼마나 큰가?...]]>
			</description>
			<link>http://lee-seungjae.github.io/ArrayVsHashMap.html</link>
		</item>
			<item>
			<title>NDC12 - 실시간 HTTP 양방향 통신</title>
			<pubDate>25 Apr 2012 00:00:00 +0900</pubDate>
			<description>
			<![CDATA[<TAG>
<iframe src="http://www.slideshare.net/slideshow/embed_code/12679447?rel=0" width="687" height="486" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/devcatpublications/http-ndc2012" title="이승재, 실시간 HTTP 양방향 통신, NDC2012" target="_blank">이승재, 실시간 HTTP 양방향 통신, NDC2012</a> </strong> from <strong><a href="http://www.slideshare.net/devcatpublications" target="_blank">devCAT Studio, NEXON</a></strong> </div>
</TAG>

2012년 4월 25일, 50분 세션....]]>
			</description>
			<link>http://lee-seungjae.github.io/BidirectionalHTTP.html</link>
		</item>
			<item>
			<title>게임에 사용할 스크립팅 환경을 고를 때 고려해야 할 것들</title>
			<pubDate>20 Nov 2011 00:00:00 +0900</pubDate>
			<description>
			<![CDATA[지난 8~9일에 부산에서 개최된 ICON에서 [온라인 게임 처음부터 끝까지 동적언어로 만들기:BuildingOnlineGameEntirelyWithDynamicLanguage]를 발표하고 왔다. 여러 달 만에 다시 보니 더 하고 싶은 얘기들이 생겨서 슬라이드를 좀 수정했는데, 분량과 흐름 상 넣지 못했던 주제가 있어서 블로그 포스트로 정리해 본다.

-------------------

스크립팅 환경을 고를 때는 언어 뿐만 아니라 런타임이 제공하는 기능이나 바인딩의 편의성, 각종 개발 도구들도 함께 고려해야 한다. 그것들이 모두 생산성에 영향을 미치기 때문이다. 어떤 기능은 언어의 기본 런타임에서 잘 지원하기도 하지만, 기본 런타임은 기초적인 API만 제공하고 필요한 기능을 만들든지 적절한 래퍼를 붙여야 할 수도 있다. 다른 환경을 깊게 경험해 보지 않아서 비교하기 어렵지만 루아는 확실히 이런 경향이 심하다. 그저 '된다더라' 로 끝나는 것이 아니라, 기능이 필요해졌을 때 도입 비용이 생길 수 있다. 처음부터 다 만들고 시작하지는 않더라도, 나중에 어느 정도의 비용이 필요할 지 예상해 두면 좋을 것이다....]]>
			</description>
			<link>http://lee-seungjae.github.io/ScriptingLanguageConsideration.html</link>
		</item>
			<item>
			<title>greenlet은 어떻게 구현했을까?</title>
			<pubDate>07 Oct 2011 00:00:00 +0900</pubDate>
			<description>
			<![CDATA[지난번 글 [WebServerArchitecture]에 이런 내용이 있었다:

 원래 파이썬에는 코루틴이 없는데, 변종 파이썬 인터프리터인 스택리스 파이썬이 코루틴을 지원했고, 이것을 기본 파이썬 인터프리터에서 사용할 수 있도록 모듈 형태로 만든 것이 greenlet이다.

...]]>
			</description>
			<link>http://lee-seungjae.github.io/greenlet.html</link>
		</item>
			<item>
			<title>웹서버 아키텍처와 프로그래밍 모델의 진화</title>
			<pubDate>03 Sep 2011 00:00:00 +0900</pubDate>
			<description>
			<![CDATA[여러 소켓에 대해 읽고 쓰기를 병행적으로 하는 기법을 I/O 멀티플렉싱이라고 부른다. 이런 기법들에는 여러 가지가 있는데, 그 중에서 스레드 하나가 소켓 하나를 처리하는 방법은 동시에 관리해야 할 소켓의 개수가 많아지면 많아질수록 성능이 아주 심하게 떨어진다. 스레드가 많아지면 컨텍스트 스위칭 비용도 많이 지불해야 하고, 메모리도 많이 소모하기 때문이다.

그런데 전통적으로 웹서버의 구조가 바로 이런 식이었다. 이 모델은 프로그래밍하기에는 편하지만, 아주 많은 요청을 동시에 처리하기에는 성능면에서 적합하지 않다. 하지만 웹서버의 미덕은 요청을 잽싸게 처리해서 끝내버리는 것이기 때문에 이런 제약이 그다지 문제가 되지 않았다. 실질적으로 웹사이트를 이용하고 있는 사람이 매우 많더라도, 매 순간에 활성화되어 있는 요청의 개수는 상대적으로 훨씬 적은 것이다.

그런데 웹서버임에도 불구하고 동시에 수천~수만 이상의 활성화된 요청을 처리해야 하는 경우가 있다. 롱 폴링이라는 기법을 쓸 때 그렇다. 롱 폴링은 웹서버에서 이벤트가 발생할 때 브라우저에게 즉시 알려주는 데 쓰는 기법으로, 웹으로 메신저나 채팅 프로그램을 만들 때 필요한 것이다. 브라우저가 XmlHttpRequest 요청을 보내면, 웹서버는 브라우저에게 전달할 내용이 있을 경우엔 즉시 응답하고, 없을 경우 전달할 내용이 생기거나 일정 시간이 지날 때까지 기다려서 응답한다. 평범한 웹사이트라면 유저가 요청한 페이지의 로딩이 끝나고 나면 다음 페이지로 넘어가기 전까지는 활성화된 요청이 없는데, 롱 폴링을 쓰는 사이트는 거의 웹사이트를 열어놓은 브라우저 개수만큼 활성화된 요청이 있게 된다. 롱 폴링을 쓰지 않더라도, 기계의 성능을 최대한 활용하고 싶은 엔지니어는 스레드 하나가 소켓 하나를 처리하는 방식이 썩 마음에 들지 않을 것이다....]]>
			</description>
			<link>http://lee-seungjae.github.io/WebServerArchitecture.html</link>
		</item>
			<item>
			<title>뭘 하고 싶은가? 맥락을 말해보라.</title>
			<pubDate>26 Jul 2011 00:00:00 +0900</pubDate>
			<description>
			<![CDATA[소프트웨어를 개발하는 도중에 맞닥뜨린 문제에 도움을 요청받았을 때, 그 문제에 대한 해답을 바로 제시하기보다는 그 문제를 해결함으로써 무엇을 얻고자 하는 것인지를 종종 묻게 된다. 주로 "뭘 하고 싶은 건데?" 내지는 "맥락을 말해봐." 라는 형태로 질문하는데, 이에 대한 배경 설명을 좀 해보려고 한다.

소프트웨어 개발을 거대한 문제 해결 과정이라고 생각해 보자. '이러저러한 것을 만든다' 라는 추상적인 목표가 근본 문제이고, 소프트웨어를 개발하는 여정은 이 근본 문제를 좀더 작고 구체적이고 해결할만해보이는 문제들로 쪼개거나(Divide and conquer), 답이 이미 알려진 문제로 변환(Reduction)하고, 이것을 재귀적으로 적용해서 문제들이 더이상 쪼개거나 변환할 필요가 없을 정도로 간단해지면, 직접 해결하는 것이다.

이런 관점에서 보면, 모든 문제는 스스로 존재하는 것이 아니라 다른 문제를 풀기 위한 해결책으로서 만들어진 것이다. 풀기 난감한 문제에 맞닥뜨렸을 때, 이 문제가 어떤 다른 문제를 쪼개거나 변환해서 만들어진 것인지, 즉 어떤 다른 문제를 풀기 위한 것인지 떠올려 보자. 쪼개거나 변환하는 방식을 달리하면 좀더 낮은 비용으로 전체 문제를 해결할 수 있는 경우가 많다....]]>
			</description>
			<link>http://lee-seungjae.github.io/TellMeTheContext.html</link>
		</item>
	</channel>
</rss>
